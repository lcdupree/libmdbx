<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmdbx: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmdbx
   &#160;<span id="projectnumber">Please fetch tags and/or use non-obsolete git version.Please fetch tags and/or use non-obsolete git version.Please fetch tags and/or use non-obsolete git version.0 (2022-04-13T11:05:50+03:00)</span>
   </div>
   <div id="projectbrief">One of the fastest compact embeddable key-value ACID database without WAL.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('intro.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="characteristics"></a>
Characteristics</h1>
<h2><a class="anchor" id="preface"></a>
Preface</h2>
<blockquote class="doxtable">
<p>For the most part, this section is a copy of the corresponding text from LMDB description, but with some edits reflecting the improvements and enhancements were made in MDBX. </p>
</blockquote>
<p>MDBX is a Btree-based database management library modeled loosely on the BerkeleyDB API, but much simplified. The entire database (aka "environment") is exposed in a memory map, and all data fetches return data directly from the mapped memory, so no malloc's or memcpy's occur during data fetches. As such, the library is extremely simple because it requires no page caching layer of its own, and it is extremely high performance and memory-efficient. It is also fully transactional with full ACID semantics, and when the memory map is read-only, the database integrity cannot be corrupted by stray pointer writes from application code.</p>
<p>The library is fully thread-aware and supports concurrent read/write access from multiple processes and threads. Data pages use a copy-on-write strategy so no active data pages are ever overwritten, which also provides resistance to corruption and eliminates the need of any special recovery procedures after a system crash. Writes are fully serialized; only one write transaction may be active at a time, which guarantees that writers can never deadlock. The database structure is multi-versioned so readers run with no locks; writers cannot block readers, and readers don't block writers.</p>
<p>Unlike other well-known database mechanisms which use either write-ahead transaction logs or append-only data writes, MDBX requires no maintenance during operation. Both write-ahead loggers and append-only databases require periodic checkpointing and/or compaction of their log or database files otherwise they grow without bound. MDBX tracks retired/freed pages within the database and re-uses them for new write operations, so the database size does not grow without bound in normal use. It is worth noting that the "next" version libmdbx (<a class="el" href="index.html#MithrilDB">MithrilDB</a>) will solve this problem.</p>
<p>The memory map can be used as a read-only or read-write map. It is read-only by default as this provides total immunity to corruption. Using read-write mode offers much higher write performance, but adds the possibility for stray application writes thru pointers to silently corrupt the database. Of course if your application code is known to be bug-free (...) then this is not an issue.</p>
<p>If this is your first time using a transactional embedded key-value store, you may find the <a class="el" href="usage.html#starting">Getting started</a> section below to be helpful.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Features</h2>
<ul>
<li>Key-value data model, keys are always sorted.</li>
<li>Fully <a href="https://en.wikipedia.org/wiki/ACID">ACID</a>-compliant, through to <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a> and <a href="https://en.wikipedia.org/wiki/Copy-on-write">CoW</a>.</li>
<li>Multiple key-value sub-databases within a single datafile.</li>
<li>Range lookups, including range query estimation.</li>
<li>Efficient support for short fixed length keys, including native 32/64-bit integers.</li>
<li>Ultra-efficient support for <a href="https://en.wikipedia.org/wiki/Multimap">multimaps</a>. Multi-values sorted, searchable and iterable. Keys stored without duplication.</li>
<li>Data is <a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped</a> and accessible directly/zero-copy. Traversal of database records is extremely-fast.</li>
<li>Transactions for readers and writers, ones do not block others.</li>
<li>Writes are strongly serialized. No transaction conflicts nor deadlocks.</li>
<li>Readers are <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">non-blocking</a>, notwithstanding <a href="https://en.wikipedia.org/wiki/Snapshot_isolation">snapshot isolation</a>.</li>
<li>Nested write transactions.</li>
<li>Reads scale linearly across CPUs.</li>
<li>Continuous zero-overhead database compactification.</li>
<li>Automatic on-the-fly database size adjustment.</li>
<li>Customizable database page size.</li>
<li><code>Olog(N)</code> cost of lookup, insert, update, and delete operations by virtue of <a href="https://en.wikipedia.org/wiki/B%2B_tree#Characteristics">B+ tree characteristics</a>.</li>
<li>Online hot backup.</li>
<li>Append operation for efficient bulk insertion of pre-sorted data.</li>
<li>No <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">WAL</a> nor any transaction journal. No crash recovery needed. No maintenance is required.</li>
<li>No internal cache and/or memory management, all done by basic OS services.</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Limitations</h2>
<ul>
<li><b>Page size</b>: a power of 2, minimum <code>256</code> (mostly for testing), maximum <code>65536</code> bytes, default <code>4096</code> bytes.</li>
<li><b>Key size</b>: minimum <code>0</code>, maximum ≈½ pagesize (<code>2022</code> bytes for default 4K pagesize, <code>32742</code> bytes for 64K pagesize).</li>
<li><b>Value size</b>: minimum <code>0</code>, maximum <code>2146435072</code> (<code>0x7FF00000</code>) bytes for maps, ≈½ pagesize for multimaps (<code>2022</code> bytes for default 4K pagesize, <code>32742</code> bytes for 64K pagesize).</li>
<li><b>Write transaction size</b>: up to <code>1327217884</code> pages (<code>4.944272</code> TiB for default 4K pagesize, <code>79.108351</code> TiB for 64K pagesize).</li>
<li><b>Database size</b>: up to <code>2147483648</code> pages (≈<code>8.0</code> TiB for default 4K pagesize, ≈<code>128.0</code> TiB for 64K pagesize).</li>
<li><b>Maximum sub-databases</b>: <code>32765</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Gotchas</h2>
<ol type="1">
<li>There cannot be more than one writer at a time, i.e. no more than one write transaction at a time.</li>
<li><em>libmdbx</em> is based on <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a>, so access to database pages is mostly random. Thus SSDs provide a significant performance boost over spinning disks for large databases.</li>
<li><em>libmdbx</em> uses <a href="https://en.wikipedia.org/wiki/Shadow_paging">shadow paging</a> instead of <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">WAL</a>. Thus syncing data to disk might be a bottleneck for write intensive workload.</li>
<li><em>libmdbx</em> uses <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> for <a href="https://en.wikipedia.org/wiki/Snapshot_isolation">snapshot isolation</a> during updates, but read transactions prevents recycling an old retired/freed pages, since it read ones. Thus altering of data during a parallel long-lived read operation will increase the process work set, may exhaust entire free database space, the database can grow quickly, and result in performance degradation. Try to avoid long running read transactions.</li>
<li><em>libmdbx</em> is extraordinarily fast and provides minimal overhead for data access, so you should reconsider using brute force techniques and double check your code. On the one hand, in the case of <em>libmdbx</em>, a simple linear search may be more profitable than complex indexes. On the other hand, if you make something suboptimally, you can notice detrimentally only on sufficiently large data.</li>
</ol>
<h2><a class="anchor" id="autotoc_md8"></a>
Comparison with other databases</h2>
<p>For now please refer to <a href="https://github.com/coreos/bbolt#comparison-with-other-databases">chapter of "BoltDB comparison with other databases"</a> which is also (mostly) applicable to <em>libmdbx</em>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Improvements beyond LMDB</h1>
<p><em>libmdbx</em> is superior to legendary <em><a href="https://symas.com/lmdb/">LMDB</a></em> in terms of features and reliability, not inferior in performance. In comparison to <em>LMDB</em>, <em>libmdbx</em> make things "just work" perfectly and out-of-the-box, not silently and catastrophically break down. The list below is pruned down to the improvements most notable and obvious from the user's point of view.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Added Features</h2>
<ol type="1">
<li>Keys could be more than 2 times longer than <em>LMDB</em>. <blockquote class="doxtable">
<p>For DB with default page size <em>libmdbx</em> support keys up to 2022 bytes and up to 32742 bytes for 64K page size. <em>LMDB</em> allows key size up to 511 bytes and may silently loses data with large values. </p>
</blockquote>
</li>
<li>Up to 30% faster than <em>LMDB</em> in <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> benchmarks. <blockquote class="doxtable">
<p>Benchmarks of the in-<a href="https://en.wikipedia.org/wiki/Tmpfs">tmpfs</a> scenarios, that tests the speed of the engine itself, showned that <em>libmdbx</em> 10-20% faster than <em>LMDB</em>, and up to 30% faster when <em>libmdbx</em> compiled with specific build options which downgrades several runtime checks to be match with LMDB behaviour.</p>
<p>These and other results could be easily reproduced with <a href="https://github.com/pmwkaa/ioarena">ioArena</a> just by <code>make bench-quartet</code> command, including comparisons with <a href="https://en.wikipedia.org/wiki/RocksDB">RockDB</a> and <a href="https://en.wikipedia.org/wiki/WiredTiger">WiredTiger</a>. </p>
</blockquote>
</li>
<li>Automatic on-the-fly database size adjustment, both increment and reduction. <blockquote class="doxtable">
<p><em>libmdbx</em> manages the database size according to parameters specified by <code><a class="el" href="group__c__settings.html#ga79065e4f3c5fb2ad37a52b59224d583e" title="Set all size-related parameters of environment, including page size and the min/max size of the memor...">mdbx_env_set_geometry()</a></code> function, ones include the growth step and the truncation threshold.</p>
<p>Unfortunately, on-the-fly database size adjustment doesn't work under <a href="https://en.wikipedia.org/wiki/Wine_(software)">Wine</a> due to its internal limitations and unimplemented functions, i.e. the <code>MDBX_UNABLE_EXTEND_MAPSIZE</code> error will be returned. </p>
</blockquote>
</li>
<li>Automatic continuous zero-overhead database compactification. <blockquote class="doxtable">
<p>During each commit <em>libmdbx</em> merges a freeing pages which adjacent with the unallocated area at the end of file, and then truncates unused space when a lot enough of. </p>
</blockquote>
</li>
<li>The same database format for 32- and 64-bit builds. <blockquote class="doxtable">
<p><em>libmdbx</em> database format depends only on the <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> but not on the <a href="https://en.wiktionary.org/wiki/bitness">bitness</a>. </p>
</blockquote>
</li>
<li>LIFO policy for Garbage Collection recycling. This can significantly increase write performance due write-back disk cache up to several times in a best case scenario. <blockquote class="doxtable">
<p>LIFO means that for reuse will be taken the latest becomes unused pages. Therefore the loop of database pages circulation becomes as short as possible. In other words, the set of pages, that are (over)written in memory and on disk during a series of write transactions, will be as small as possible. Thus creates ideal conditions for the battery-backed or flash-backed disk cache efficiency. </p>
</blockquote>
</li>
<li>Fast estimation of range query result volume, i.e. how many items can be found between a <code>KEY1</code> and a <code>KEY2</code>. This is a prerequisite for build and/or optimize query execution plans. <blockquote class="doxtable">
<p><em>libmdbx</em> performs a rough estimate based on common B-tree pages of the paths from root to corresponding keys. </p>
</blockquote>
</li>
<li><code>mdbx_chk</code> utility for database integrity check. Since version 0.9.1, the utility supports checking the database using any of the three meta pages and the ability to switch to it.</li>
<li>Support for opening databases in the exclusive mode, including on a network share.</li>
<li>Zero-length for keys and values.</li>
<li>Ability to determine whether the particular data is on a dirty page or not, that allows to avoid copy-out before updates.</li>
<li>Extended information of whole-database, sub-databases, transactions, readers enumeration. <blockquote class="doxtable">
<p><em>libmdbx</em> provides a lot of information, including dirty and leftover pages for a write transaction, reading lag and holdover space for read transactions. </p>
</blockquote>
</li>
<li>Extended update and delete operations. <blockquote class="doxtable">
<p><em>libmdbx</em> allows one <em>at once</em> with getting previous value and addressing the particular item from multi-value with the same key. </p>
</blockquote>
</li>
<li>Useful runtime options for tuning engine to application's requirements and use cases specific.</li>
<li>Automated steady sync-to-disk upon several thresholds and/or timeout via cheap polling.</li>
<li>Sequence generation and three persistent 64-bit markers.</li>
<li>Handle-Slow-Readers callback to resolve a database full/overflow issues due to long-lived read transaction(s).</li>
<li>Ability to determine whether the cursor is pointed to a key-value pair, to the first, to the last, or not set to anything.</li>
</ol>
<h2><a class="anchor" id="autotoc_md11"></a>
Other fixes and specifics</h2>
<ol type="1">
<li>Fixed more than 10 significant errors, in particular: page leaks, wrong sub-database statistics, segfault in several conditions, nonoptimal page merge strategy, updating an existing record with a change in data size (including for multimap), etc.</li>
<li>All cursors can be reused and should be closed explicitly, regardless ones were opened within a write or read transaction.</li>
<li>Opening database handles are spared from race conditions and pre-opening is not needed.</li>
<li>Returning <code>MDBX_EMULTIVAL</code> error in case of ambiguous update or delete.</li>
<li>Guarantee of database integrity even in asynchronous unordered write-to-disk mode. <blockquote class="doxtable">
<p><em>libmdbx</em> propose additional trade-off by <code>MDBX_SAFE_NOSYNC</code> with append-like manner for updates, that avoids database corruption after a system crash contrary to LMDB. Nevertheless, the <code>MDBX_UTTERLY_NOSYNC</code> mode is available to match LMDB's behaviour for <code>MDB_NOSYNC</code>. </p>
</blockquote>
</li>
<li>On <b>MacOS &amp; iOS</b> the <code>fcntl(F_FULLFSYNC)</code> syscall is used <em>by default</em> to synchronize data with the disk, as this is [the only way to guarantee data durability](<a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/fsync.2.html">https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/fsync.2.html</a>) in case of power failure. Unfortunately, in scenarios with high write intensity, the use of <code>F_FULLFSYNC</code> significantly degrades performance compared to LMDB, where the <code>fsync()</code> syscall is used. Therefore, <em>libmdbx</em> allows you to override this behavior by defining the <code>MDBX_OSX_SPEED_INSTEADOF_DURABILITY=1</code> option while build the library.</li>
<li>On <b>Windows</b> the <code>LockFileEx()</code> syscall is used for locking, since it allows place the database on network drives, and provides protection against incompetent user actions (aka <a href="https://en.wikipedia.org/wiki/Poka-yoke">poka-yoke</a>). Therefore <em>libmdbx</em> may be a little lag in performance tests from LMDB where the named mutexes are used.</li>
</ol>
<h1><a class="anchor" id="restrictions"></a>
Restrictions &amp; Caveats</h1>
<p>In addition to those listed for some functions.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Troubleshooting the LCK-file</h2>
<ol type="1">
<li><p class="startli">A broken LCK-file can cause sync issues, including appearance of wrong/inconsistent data for readers. When database opened in the cooperative read-write mode the LCK-file requires to be mapped to memory in read-write access. In this case it is always possible for stray/malfunctioned application could writes thru pointers to silently corrupt the LCK-file.</p>
<p class="startli">Unfortunately, there is no any portable way to prevent such corruption, since the LCK-file is updated concurrently by multiple processes in a lock-free manner and any locking is unwise due to a large overhead.</p>
<p class="startli">The "next" version of libmdbx (<a class="el" href="index.html#MithrilDB">MithrilDB</a>) will solve this issue.</p>
<dl class="section note"><dt>Note</dt><dd>Workaround: Just make all programs using the database close it; the LCK-file is always reset on first open.</dd></dl>
</li>
<li><p class="startli">Stale reader transactions left behind by an aborted program cause further writes to grow the database quickly, and stale locks can block further operation. MDBX checks for stale readers while opening environment and before growth the database. But in some cases, this may not be enough.</p>
<dl class="section note"><dt>Note</dt><dd>Workaround: Check for stale readers periodically, using the <a class="el" href="group__c__extra.html#ga15d520b1259aa361a4214f8d8f88c6c5">mdbx_reader_check()</a> function or the mdbx_stat tool.</dd></dl>
</li>
<li><p class="startli">Stale writers will be cleared automatically by MDBX on supported platforms. But this is platform-specific, especially of implementation of shared POSIX-mutexes and support for robust mutexes. For instance there are no known issues on Linux, OSX, Windows and FreeBSD.</p>
<dl class="section note"><dt>Note</dt><dd>Workaround: Otherwise just make all programs using the database close it; the LCK-file is always reset on first open of the environment.</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
Remote filesystems</h2>
<p>Do not use MDBX databases on remote filesystems, even between processes on the same host. This breaks file locks on some platforms, possibly memory map sync, and certainly sync between programs on different hosts.</p>
<p>On the other hand, MDBX support the exclusive database operation over a network, and cooperative read-only access to the database placed on a read-only network shares.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Child processes</h2>
<p>Do not use opened <a class="el" href="group__c__api.html#gaaf0e4c9dc12dce0c2a98566436c94222">MDBX_env</a> instance(s) in a child processes after <code>fork()</code>. It would be insane to call fork() and any MDBX-functions simultaneously from multiple threads. The best way is to prevent the presence of open MDBX-instances during <code>fork()</code>.</p>
<p>The <a class="el" href="group__build__option.html#gaf071d5f94e60959acc27800a67381827">MDBX_ENV_CHECKPID</a> build-time option, which is ON by default on non-Windows platforms (i.e. where <code>fork()</code> is available), enables PID checking at a few critical points. But this does not give any guarantees, but only allows you to detect such errors a little sooner. Depending on the platform, you should expect an application crash and/or database corruption in such cases.</p>
<p>On the other hand, MDBX allow calling <a class="el" href="group__c__opening.html#ga3945614a024b9f9eb48e4ffa205b68be">mdbx_env_close()</a> in such cases to release resources, but no more and in general this is a wrong way.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Read-only mode</h2>
<p>There is no pure read-only mode in a normal explicitly way, since readers need write access to LCK-file to be ones visible for writer.</p>
<p>So MDBX always tries to open/create LCK-file for read-write, but switches to without-LCK mode on appropriate errors (<code>EROFS</code>, <code>EACCESS</code>, <code>EPERM</code>) if the read-only mode was requested by the <a class="el" href="group__c__opening.html#gga9138119a904355d245777c4119534061adc513be607ba103d642f49afc2d50e50">MDBX_RDONLY</a> flag which is described below.</p>
<p>The "next" version of libmdbx (<a class="el" href="index.html#MithrilDB">MithrilDB</a>) will solve this issue for the "many
readers without writer" case.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
One thread - One transaction</h2>
<p>A thread can only use one transaction at a time, plus any nested read-write transactions in the non-writemap mode. Each transaction belongs to one thread. The <a class="el" href="group__c__opening.html#gga9138119a904355d245777c4119534061a79e1de212a2f3a1018c2da2c4b511cb8">MDBX_NOTLS</a> flag changes this for read-only transactions. See below.</p>
<p>Do not start more than one transaction for a one thread. If you think about this, it's really strange to do something with two data snapshots at once, which may be different. MDBX checks and preventing this by returning corresponding error code (<a class="el" href="group__c__err.html#ggab5ba1469eef28a2e09ed243b608b11cea451522504ab193716f8f3b4396b2b614">MDBX_TXN_OVERLAPPING</a>, <a class="el" href="group__c__err.html#ggab5ba1469eef28a2e09ed243b608b11ceab12b07210795dae90a638c527df62dcc">MDBX_BAD_RSLOT</a>, <a class="el" href="group__c__err.html#ggab5ba1469eef28a2e09ed243b608b11cea971ec6ff2bc8db798c920a3bde3bab5d">MDBX_BUSY</a>) unless you using <a class="el" href="group__c__opening.html#gga9138119a904355d245777c4119534061a79e1de212a2f3a1018c2da2c4b511cb8">MDBX_NOTLS</a> option on the environment. Nonetheless, with the <code>MDBX_NOTLS</code> option, you must know exactly what you are doing, otherwise you will get deadlocks or reading an alien data.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Do not open twice</h2>
<p>Do not have open an MDBX database twice in the same process at the same time. By default MDBX prevent this in most cases by tracking databases opening and return <a class="el" href="group__c__err.html#ggab5ba1469eef28a2e09ed243b608b11cea971ec6ff2bc8db798c920a3bde3bab5d">MDBX_BUSY</a> if anyone LCK-file is already open.</p>
<p>The reason for this is that when the "Open file description" locks (aka OFD-locks) are not available, MDBX uses POSIX locks on files, and these locks have issues if one process opens a file multiple times. If a single process opens the same environment multiple times, closing it once will remove all the locks held on it, and the other instances will be vulnerable to corruption from other processes.</p>
<p>For compatibility with LMDB which allows multi-opening, MDBX can be configured at runtime by <code>mdbx_setup_debug(MDBX_DBG_LEGACY_MULTIOPEN, ...)</code> prior to calling other MDBX functions. In this way MDBX will track databases opening, detect multi-opening cases and then recover POSIX file locks as necessary. However, lock recovery can cause unexpected pauses, such as when another process opened the database in exclusive mode before the lock was restored - we have to wait until such a process releases the database, and so on.</p>
<h2><a class="anchor" id="long-lived-read"></a>
Long-lived read transactions</h2>
<p>Avoid long-lived read transactions, especially in the scenarios with a high rate of write transactions. Long-lived read transactions prevents recycling pages retired/freed by newer write transactions, thus the database can grow quickly.</p>
<p>Understanding the problem of long-lived read transactions requires some explanation, but can be difficult for quick perception. So is is reasonable to simplify this as follows:</p><ol type="1">
<li>Garbage collection problem exists in all databases one way or another, e.g. VACUUM in PostgreSQL. But in MDBX it's even more discernible because of high transaction rate and intentional internals simplification in favor of performance.</li>
<li>MDBX employs <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion concurrency control</a> on the <a href="https://en.wikipedia.org/wiki/Copy-on-write">Copy-on-Write</a> basis, that allows multiple readers runs in parallel with a write transaction without blocking. An each write transaction needs free pages to put the changed data, that pages will be placed in the new b-tree snapshot at commit. MDBX efficiently recycling pages from previous created unused snapshots, BUT this is impossible if anyone a read transaction use such snapshot.</li>
<li>Thus massive altering of data during a parallel long read operation will increase the process's work set and may exhaust entire free database space.</li>
</ol>
<p>A good example of long readers is a hot backup to the slow destination or debugging of a client application while retaining an active read transaction. LMDB this results in <code>MDB_MAP_FULL</code> error and subsequent write performance degradation.</p>
<p>MDBX mostly solve "long-lived" readers issue by using the Handle-Slow-Readers <a class="el" href="group__c__err.html#gaedc09dd7e0634163be8aafdf00d7db77">MDBX_hsr_func</a> callback which allows to abort long-lived read transactions, and using the <a class="el" href="group__c__opening.html#gga9138119a904355d245777c4119534061a37585486d4e99bcb599cc15b408137b0">MDBX_LIFORECLAIM</a> mode which addresses subsequent performance degradation. The "next" version of libmdbx (<a class="el" href="index.html#MithrilDB">MithrilDB</a>) will completely solve this.</p>
<ul>
<li>Avoid suspending a process with active transactions. These would then be "long-lived" as above.</li>
<li>Avoid aborting a process with an active read-only transaction in scenarios with high rate of write transactions. The transaction becomes "long-lived" as above until a check for stale readers is performed or the LCK-file is reset, since the process may not remove it from the lockfile. This does not apply to write transactions if the system clears stale writers, see above.</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Large data items and huge transactions</h2>
<p>MDBX allows you to store values up to 1 gigabyte in size, but this is not the main functionality for a key-value storage, but an additional feature that should not be abused. Such long values are stored in consecutive/adjacent DB pages, which has both pros and cons. This allows you to read long values directly without copying and without any overhead from a linear section of memory.</p>
<p>On the other hand, when putting such values in the database, it is required to find a sufficient number of free consecutive/adjacent database pages, which can be very difficult and expensive, moreover sometimes impossible since b-tree tends to fragmentation. So, when placing very long values, the engine may need to process the entire GC, and in the absence of a sufficient sequence of free pages, increase the DB file. Thus, for long values, MDBX provides maximum read performance at the expense of write performance.</p>
<p>A similar situation can be with huge transactions, in which a lot of database pages are retired. The retired pages should be put into GC as a list of page numbers for future reuse. But in huge transactions, such a list of retired page numbers can also be huge, i.e. it is a very long value and requires a long sequence of free pages to be saved. Thus, if you delete large amounts of information from the database in a single transaction, MDBX may need to increase the database file to save the list of pages to be retired.</p>
<p>Both of these issues will be addressed in MithrilDB.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Space reservation</h2>
<p>An MDBX database configuration will often reserve considerable unused memory address space and maybe file size for future growth. This does not use actual memory or disk space, but users may need to understand the difference so they won't be scared off.</p>
<h1><a class="anchor" id="performance"></a>
Performance comparison</h1>
<p>All benchmarks were done in 2015 by <a href="https://github.com/pmwkaa/ioarena">IOArena</a> and multiple <a href="https://github.com/pmwkaa/ioarena/tree/HL%2B%2B2015">scripts</a> runs on Lenovo Carbon-2 laptop, i7-4600U 2.1 GHz (2 physical cores, 4 HyperThreading cores), 8 Gb RAM, SSD SAMSUNG MZNTD512HAGL-000L1 (DXT23L0Q) 512 Gb.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Integral performance</h2>
<p>Here showed sum of performance metrics in 3 benchmarks:</p>
<ul>
<li>Read/Search on the machine with 4 logical CPUs in HyperThreading mode (i.e. actually 2 physical CPU cores);</li>
<li>Transactions with <a href="https://en.wikipedia.org/wiki/CRUD">CRUD</a> operations in sync-write mode (fdatasync is called after each transaction);</li>
<li>Transactions with <a href="https://en.wikipedia.org/wiki/CRUD">CRUD</a> operations in lazy-write mode (moment to sync data to persistent storage is decided by OS).</li>
</ul>
<p><em>Reasons why asynchronous mode isn't benchmarked here:</em></p>
<ol type="1">
<li>It doesn't make sense as it has to be done with DB engines, oriented for keeping data in memory e.g. <a href="https://tarantool.io/">Tarantool</a>, <a href="https://redis.io/">Redis</a>), etc.</li>
<li>Performance gap is too high to compare in any meaningful way.</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wiki/erthink/libmdbx/img/perf-slide-1.png" alt="Comparison #1: Integral Performance" class="inline"/></p>
<hr  />
<h2><a class="anchor" id="autotoc_md22"></a>
Read Scalability</h2>
<p>Summary performance with concurrent read/search queries in 1-2-4-8 threads on the machine with 4 logical CPUs in HyperThreading mode (i.e. actually 2 physical CPU cores).</p>
<p><img src="https://raw.githubusercontent.com/wiki/erthink/libmdbx/img/perf-slide-2.png" alt="Comparison #2: Read Scalability" class="inline"/></p>
<hr  />
<h2><a class="anchor" id="autotoc_md24"></a>
Sync-write mode</h2>
<ul>
<li>Linear scale on left and dark rectangles mean arithmetic mean transactions per second;</li>
<li>Logarithmic scale on right is in seconds and yellow intervals mean execution time of transactions. Each interval shows minimal and maximum execution time, cross marks standard deviation.</li>
</ul>
<p><b>10,000 transactions in sync-write mode</b>. In case of a crash all data is consistent and conforms to the last successful transaction. The <a href="https://linux.die.net/man/2/fdatasync">fdatasync</a> syscall is used after each write transaction in this mode.</p>
<p>In the benchmark each transaction contains combined CRUD operations (2 inserts, 1 read, 1 update, 1 delete). Benchmark starts on an empty database and after full run the database contains 10,000 small key-value records.</p>
<p><img src="https://raw.githubusercontent.com/wiki/erthink/libmdbx/img/perf-slide-3.png" alt="Comparison #3: Sync-write mode" class="inline"/></p>
<hr  />
<h2><a class="anchor" id="autotoc_md26"></a>
Lazy-write mode</h2>
<ul>
<li>Linear scale on left and dark rectangles mean arithmetic mean of thousands transactions per second;</li>
<li>Logarithmic scale on right in seconds and yellow intervals mean execution time of transactions. Each interval shows minimal and maximum execution time, cross marks standard deviation.</li>
</ul>
<p><b>100,000 transactions in lazy-write mode</b>. In case of a crash all data is consistent and conforms to the one of last successful transactions, but transactions after it will be lost. Other DB engines use <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">WAL</a> or transaction journal for that, which in turn depends on order of operations in the journaled filesystem. <em>libmdbx</em> doesn't use WAL and hands I/O operations to filesystem and OS kernel (mmap).</p>
<p>In the benchmark each transaction contains combined CRUD operations (2 inserts, 1 read, 1 update, 1 delete). Benchmark starts on an empty database and after full run the database contains 100,000 small key-value records.</p>
<p><img src="https://raw.githubusercontent.com/wiki/erthink/libmdbx/img/perf-slide-4.png" alt="Comparison #4: Lazy-write mode" class="inline"/></p>
<hr  />
<h2><a class="anchor" id="autotoc_md28"></a>
Async-write mode</h2>
<ul>
<li>Linear scale on left and dark rectangles mean arithmetic mean of thousands transactions per second;</li>
<li>Logarithmic scale on right in seconds and yellow intervals mean execution time of transactions. Each interval shows minimal and maximum execution time, cross marks standard deviation.</li>
</ul>
<p><b>1,000,000 transactions in async-write mode</b>. In case of a crash all data is consistent and conforms to the one of last successful transactions, but lost transaction count is much higher than in lazy-write mode. All DB engines in this mode do as little writes as possible on persistent storage. <em>libmdbx</em> uses <a href="https://linux.die.net/man/2/msync">msync(MS_ASYNC)</a> in this mode.</p>
<p>In the benchmark each transaction contains combined CRUD operations (2 inserts, 1 read, 1 update, 1 delete). Benchmark starts on an empty database and after full run the database contains 10,000 small key-value records.</p>
<p><img src="https://raw.githubusercontent.com/wiki/erthink/libmdbx/img/perf-slide-5.png" alt="Comparison #5: Async-write mode" class="inline"/></p>
<hr  />
<h2><a class="anchor" id="autotoc_md30"></a>
Cost comparison</h2>
<p>Summary of used resources during lazy-write mode benchmarks:</p>
<ul>
<li>Read and write IOPs;</li>
<li>Sum of user CPU time and sys CPU time;</li>
<li>Used space on persistent storage after the test and closed DB, but not waiting for the end of all internal housekeeping operations (LSM compactification, etc).</li>
</ul>
<p><em>ForestDB</em> is excluded because benchmark showed it's resource consumption for each resource (CPU, IOPs) much higher than other engines which prevents to meaningfully compare it with them.</p>
<p>All benchmark data is gathered by <a href="http://man7.org/linux/man-pages/man2/getrusage.2.html">getrusage()</a> syscall and by scanning the data directory.</p>
<p><img src="https://raw.githubusercontent.com/wiki/erthink/libmdbx/img/perf-slide-6.png" alt="Comparison #6: Cost comparison" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
